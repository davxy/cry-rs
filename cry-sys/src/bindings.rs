/* automatically generated by rust-bindgen 0.59.2 */

pub const CRY_PRE_RELEASE: &[u8; 4usize] = b"rc1\0";
pub const CRY_MAJOR: u32 = 0;
pub const CRY_MINOR: u32 = 1;
pub const CRY_PATCH: u32 = 3;
pub const CRY_STABLE: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 34;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const CRY_ERROR_BAD_DATA: i32 = -1;
pub const CRY_ERROR_OUT_OF_MEMORY: i32 = -2;
pub const CRY_ERROR_NOT_IMPLEMENTED: i32 = -3;
pub const CRY_ERROR_OTHER: i32 = -42;
pub const CRY_MPI_DIGIT_BYTES: u32 = 8;
pub const CRY_MPI_DIGIT_BITS: u32 = 64;
pub const CRY_ECP_GRP_SECP192R1: u32 = 0;
pub const CRY_ECP_GRP_SECP224R1: u32 = 1;
pub const CRY_ECP_GRP_SECP256R1: u32 = 2;
pub const CRY_ECP_GRP_SECP384R1: u32 = 3;
pub const CRY_ECP_GRP_SECP521R1: u32 = 4;
pub const CRY_ECP_GRP_SECP192K1: u32 = 5;
pub const CRY_ECP_GRP_SECP224K1: u32 = 6;
pub const CRY_ECP_GRP_SECP256K1: u32 = 7;
pub const CRY_ECP_GRP_BP256R1: u32 = 8;
pub const CRY_ECP_GRP_BP384R1: u32 = 9;
pub const CRY_ECP_GRP_BP512R1: u32 = 10;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CRY_AES_BLOCK_SIZE: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const CRY_DES_BLOCK_SIZE: u32 = 8;
pub const CRY_TRIVIUM_KEYLEN: u32 = 10;
pub const CRY_TRIVIUM_IVLEN: u32 = 10;
pub const CRY_RSA_PADDING_NONE: u32 = 0;
pub const CRY_RSA_PADDING_PKCS_V15: u32 = 1;
pub const CRY_RSA_PADDING_PKCS_V21: u32 = 2;
pub const CRY_CBC_BLOCK_MAX: u32 = 16;
pub const CRY_CFB_BLOCK_MAX: u32 = 16;
pub const CRY_GCM_BLOCK_SIZE: u32 = 16;
pub const CRY_MD5_DIGEST_SIZE: u32 = 16;
pub const CRY_SHA1_DIGEST_SIZE: u32 = 20;
pub const CRY_SHA256_DIGEST_SIZE: u32 = 32;
pub const CRY_SHA512_DIGEST_SIZE: u32 = 64;
pub const CRY_CMAC_BLOCK_SIZE: u32 = 16;
pub const CRY_HMAC_BLOCK_MAX: u32 = 64;
pub const CRY_CRC_FLAG_COMPLEMENT: u32 = 1;
pub const CRY_CRC_FLAG_SWAP: u32 = 2;
pub const CRY_AFFINE_KEYMAX: u32 = 32;
pub const CRY_HILL_KEYDIM_MAX: u32 = 10;
pub const CRY_HILL_KEYLEN_MAX: u32 = 100;
pub const CRY_HILL_KEYGEN_TRIALS: u32 = 100;
extern "C" {
    #[doc = " Get library version number."]
    #[doc = ""]
    #[doc = " @return  Library version number (CRY_VERSION) at build time."]
    pub fn cry_version() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Get library version string."]
    #[doc = ""]
    #[doc = " @return  Library version string (CRY_VERSION_STR) at build time."]
    pub fn cry_version_str() -> *const ::std::os::raw::c_char;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn cry_base64_encode(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_base64_decode(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XOR two memory regions."]
    #[doc = ""]
    #[doc = " The result is stored in the first operand."]
    #[doc = " The memory segments may overlap and can work inplace."]
    #[doc = ""]
    #[doc = " @param dst   First source and destination."]
    #[doc = " @param src   Second source."]
    #[doc = " @param size  Number of bytes to XOR."]
    pub fn cry_memxor(
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " XOR two memory regions."]
    #[doc = ""]
    #[doc = " The memory segments may overlap and can work inplace."]
    #[doc = ""]
    #[doc = " @param dst   Destination."]
    #[doc = " @param src1  First source."]
    #[doc = " @param src2  Second source."]
    #[doc = " @param size  Number of bytes to XOR."]
    pub fn cry_memxor2(
        dst: *mut ::std::os::raw::c_uchar,
        src1: *const ::std::os::raw::c_uchar,
        src2: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Strong pseudo random number generator initialization."]
    #[doc = ""]
    #[doc = " Because very often people forget to perform initialization, other prng"]
    #[doc = " functions will automatically check to see if this routine has been called"]
    #[doc = " and call it at that point if not."]
    #[doc = ""]
    #[doc = " @param   seed        Seed data."]
    #[doc = " @param   seed_siz    Seed data size."]
    #[doc = " @return              Operation result."]
    pub fn cry_prng_aes_init(
        seed: *const ::std::os::raw::c_uchar,
        seed_siz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Strong pseudo random number generator production."]
    #[doc = ""]
    #[doc = " @param buf   Destination buffer"]
    #[doc = " @param siz   Destination buffer size."]
    #[doc = " @return      Operation result."]
    pub fn cry_prng_aes_rand(
        buf: *mut ::std::os::raw::c_uchar,
        siz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LFSR-113 pseudo random number generator initialization."]
    #[doc = ""]
    #[doc = " Because very often people forget to perform initialization, other prng"]
    #[doc = " functions will automatically check to see if this routine has been called"]
    #[doc = " and call it at that point if not."]
    #[doc = ""]
    #[doc = " @param   seed        Seed data."]
    #[doc = " @param   seed_siz    Seed data size."]
    #[doc = " @return              Operation result."]
    pub fn cry_prng_lfsr113_init(
        seed: *const ::std::os::raw::c_uchar,
        seed_siz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LFSR-113 pseudo random number generator production."]
    #[doc = ""]
    #[doc = " @param buf   Destination buffer"]
    #[doc = " @param siz   Destination buffer size."]
    #[doc = " @return      Operation result."]
    pub fn cry_prng_lfsr113_rand(
        buf: *mut ::std::os::raw::c_uchar,
        siz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wrap keys with AES Key Wrap Algorithm (RFC-3394)"]
    #[doc = ""]
    #[doc = " If input length is n blocks then output length is n+1 blocks."]
    #[doc = ""]
    #[doc = " @param out    Cipher-text output."]
    #[doc = " @param in     Plain-text input."]
    #[doc = " @param len    Length of the plain-text (in)."]
    #[doc = " @param key    Key-Encryption Key (KEK)."]
    #[doc = " @param keylen KEK length."]
    #[doc = " @return       Operation result."]
    pub fn cry_aes_wrap(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
        key: *const ::std::os::raw::c_uchar,
        keylen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unwrap keys with AES Key Wrap Algorithm (RFC-3394)"]
    #[doc = ""]
    #[doc = " If input length is n blocks then output length is n+1 blocks."]
    #[doc = ""]
    #[doc = " @param out    Plain-text output."]
    #[doc = " @param in     Cipher-text input."]
    #[doc = " @param len    Length of the plain-text (out)."]
    #[doc = " @param key    Key-Encryption Key (KEK)."]
    #[doc = " @param keylen KEK length."]
    #[doc = " @return       Operation result."]
    pub fn cry_aes_unwrap(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
        key: *const ::std::os::raw::c_uchar,
        keylen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Digit type definition"]
pub type cry_mpi_digit = ::std::os::raw::c_ulong;
#[doc = " MPI structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_mpi {
    #[doc = "< Non-zero if negative"]
    pub sign: ::std::os::raw::c_int,
    #[doc = "< Number of used digits"]
    pub used: size_t,
    #[doc = "< Allocated digits"]
    pub alloc: size_t,
    #[doc = "< Pointer to digits"]
    pub data: *mut cry_mpi_digit,
}
#[test]
fn bindgen_test_layout_cry_mpi() {
    assert_eq!(
        ::core::mem::size_of::<cry_mpi>(),
        32usize,
        concat!("Size of: ", stringify!(cry_mpi))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_mpi>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_mpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_mpi>())).sign as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_mpi),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_mpi>())).used as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_mpi),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_mpi>())).alloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_mpi),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_mpi>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_mpi),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub static g_zero: cry_mpi;
}
extern "C" {
    pub static g_one: cry_mpi;
}
extern "C" {
    pub static g_three: cry_mpi;
}
extern "C" {
    pub fn cry_mpi_init(a: *mut cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_clear(a: *mut cry_mpi);
}
extern "C" {
    pub fn cry_mpi_copy(d: *mut cry_mpi, s: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_copy(d: *mut cry_mpi, s: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_size(a: *mut cry_mpi, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_int(a: *mut cry_mpi, val: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_set_int(a: *mut cry_mpi, val: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_get_int(
        a: *mut cry_mpi,
        val: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_bin(
        a: *mut cry_mpi,
        b: *const ::core::ffi::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_load_bin(
        a: *mut cry_mpi,
        b: *const ::core::ffi::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_store_bin(
        a: *const cry_mpi,
        b: *mut ::core::ffi::c_void,
        size: size_t,
        pad: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_str(
        a: *mut cry_mpi,
        radix: ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_load_str(
        a: *mut cry_mpi,
        radix: ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_store_str(
        a: *const cry_mpi,
        radix: ::std::os::raw::c_uint,
        s: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_init_list(a: *mut cry_mpi, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_clear_list(a: *mut cry_mpi, ...);
}
extern "C" {
    pub fn cry_mpi_abs(d: *mut cry_mpi, s: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_add_abs(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sub_abs(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_abs(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_div_abs(
        q: *mut cry_mpi,
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_add(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sub(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_div(
        q: *mut cry_mpi,
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sqr(r: *mut cry_mpi, a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sqrt(r: *mut cry_mpi, a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_shl(c: *mut cry_mpi, a: *const cry_mpi, n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_shr(c: *mut cry_mpi, a: *const cry_mpi, n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_exp(
        r: *mut cry_mpi,
        b: *const cry_mpi,
        e: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mod_exp(
        r: *mut cry_mpi,
        b: *const cry_mpi,
        e: *const cry_mpi,
        m: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_gcd(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_lcm(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_inv(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        m: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_baseline(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_comba(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_karatsuba(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_toom3(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: *const cry_mpi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sqr_baseline(r: *mut cry_mpi, a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sqr_comba(r: *mut cry_mpi, a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_sqr_karatsuba(r: *mut cry_mpi, a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_cmp_abs(a: *const cry_mpi, b: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_cmp(a: *const cry_mpi, b: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_count_bits(a: *const cry_mpi) -> size_t;
}
extern "C" {
    pub fn cry_mpi_print(a: *const cry_mpi, radix: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cry_mpi_rand(a: *mut cry_mpi, bits: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_rand_range(a: *mut cry_mpi, max: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_prime(
        a: *mut cry_mpi,
        bits: size_t,
        iter: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_is_prime(a: *const cry_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_mpi_mul_dig(
        r: *mut cry_mpi,
        a: *const cry_mpi,
        b: cry_mpi_digit,
    ) -> ::std::os::raw::c_int;
}
#[doc = " EC point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ecp {
    pub x: cry_mpi,
    pub y: cry_mpi,
    pub z: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_ecp() {
    assert_eq!(
        ::core::mem::size_of::<cry_ecp>(),
        96usize,
        concat!("Size of: ", stringify!(cry_ecp))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ecp>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ecp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp>())).y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp>())).z as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ecp_grp {
    #[doc = "< Modulus"]
    pub p: cry_mpi,
    #[doc = "< x coefficient"]
    pub a: cry_mpi,
    #[doc = "< Constant"]
    pub b: cry_mpi,
    #[doc = "< Generator point"]
    pub g: cry_ecp,
    #[doc = "< Generator order"]
    pub n: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_ecp_grp() {
    assert_eq!(
        ::core::mem::size_of::<cry_ecp_grp>(),
        224usize,
        concat!("Size of: ", stringify!(cry_ecp_grp))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ecp_grp>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ecp_grp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp_grp>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp_grp),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp_grp>())).a as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp_grp),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp_grp>())).b as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp_grp),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp_grp>())).g as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp_grp),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecp_grp>())).n as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecp_grp),
            "::",
            stringify!(n)
        )
    );
}
extern "C" {
    pub fn cry_ecp_init(p: *mut cry_ecp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_clear(p: *mut cry_ecp);
}
extern "C" {
    pub fn cry_ecp_init_int(
        p: *mut cry_ecp,
        x: ::std::os::raw::c_long,
        y: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_copy(pr: *mut cry_ecp, p1: *const cry_ecp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_add(
        pr: *mut cry_ecp,
        p1: *const cry_ecp,
        p2: *const cry_ecp,
        grp: *const cry_ecp_grp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_dbl(
        pr: *mut cry_ecp,
        p1: *const cry_ecp,
        grp: *const cry_ecp_grp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_mul(
        pr: *mut cry_ecp,
        p1: *const cry_ecp,
        k: *const cry_mpi,
        grp: *const cry_ecp_grp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_init_list(p: *mut cry_ecp, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_clear_list(p: *mut cry_ecp, ...);
}
extern "C" {
    pub fn cry_ecp_grp_init(grp: *mut cry_ecp_grp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecp_grp_clear(grp: *mut cry_ecp_grp);
}
extern "C" {
    pub fn cry_ecp_grp_load(
        grp: *mut cry_ecp_grp,
        grp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Context initialization."]
#[doc = ""]
#[doc = " @param ctx   Cipher context"]
pub type cry_ciph_init_f =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " Context cleanup."]
#[doc = ""]
#[doc = " @param ctx   Cipher context"]
pub type cry_ciph_clear_f =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " Key set."]
#[doc = ""]
#[doc = " @param ctx   Cipher context."]
#[doc = " @param key   Key."]
#[doc = " @param size  Key size."]
pub type cry_ciph_key_set_f = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    ),
>;
#[doc = " Encrypt function pointer type."]
#[doc = ""]
#[doc = " @param ctx   Cipher context."]
#[doc = " @param dst   Destination buffer."]
#[doc = " @param src   Source buffer."]
#[doc = " @param size  Size of source/destination buffers."]
pub type cry_ciph_encrypt_f = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    ),
>;
#[doc = " Decrypt function pointer type."]
#[doc = ""]
#[doc = " @param ctx   Cipher context."]
#[doc = " @param dst   Destination buffer."]
#[doc = " @param src   Source buffer."]
#[doc = " @param size  Size of source/destination buffers."]
pub type cry_ciph_decrypt_f = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    ),
>;
#[doc = " Cipher algorithm generic interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ciph_itf {
    pub init: cry_ciph_init_f,
    pub clear: cry_ciph_clear_f,
    pub key_set: cry_ciph_key_set_f,
    pub encrypt: cry_ciph_encrypt_f,
    pub decrypt: cry_ciph_decrypt_f,
}
#[test]
fn bindgen_test_layout_cry_ciph_itf() {
    assert_eq!(
        ::core::mem::size_of::<cry_ciph_itf>(),
        40usize,
        concat!("Size of: ", stringify!(cry_ciph_itf))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ciph_itf>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ciph_itf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ciph_itf>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ciph_itf),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ciph_itf>())).clear as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ciph_itf),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ciph_itf>())).key_set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ciph_itf),
            "::",
            stringify!(key_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ciph_itf>())).encrypt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ciph_itf),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ciph_itf>())).decrypt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ciph_itf),
            "::",
            stringify!(decrypt)
        )
    );
}
#[doc = " Context initialization."]
#[doc = ""]
#[doc = " @param ctx   Hash context"]
pub type cry_hash_init_f =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " Context cleanup."]
#[doc = ""]
#[doc = " @param ctx   Hash context"]
pub type cry_hash_clear_f =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " Digest update"]
#[doc = ""]
#[doc = " @param ctx   Hash context"]
#[doc = " @param data  Input data"]
#[doc = " @param suze  Input size"]
pub type cry_hash_update_f = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ),
>;
#[doc = " Finalize."]
#[doc = ""]
#[doc = " @param ctx    Hash context"]
#[doc = " @param digest Preallocated output buffer"]
pub type cry_hash_digest_f = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void, digest: *mut ::std::os::raw::c_uchar),
>;
#[doc = " Hash algorithm generic interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_hash_itf {
    #[doc = "< Initialize (optional)"]
    pub init: cry_hash_init_f,
    #[doc = "< Clear (optional)"]
    pub clear: cry_hash_clear_f,
    #[doc = "< Update"]
    pub update: cry_hash_update_f,
    #[doc = "< Digest (finalize)"]
    pub digest: cry_hash_digest_f,
}
#[test]
fn bindgen_test_layout_cry_hash_itf() {
    assert_eq!(
        ::core::mem::size_of::<cry_hash_itf>(),
        32usize,
        concat!("Size of: ", stringify!(cry_hash_itf))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_hash_itf>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_hash_itf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hash_itf>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hash_itf),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hash_itf>())).clear as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hash_itf),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hash_itf>())).update as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hash_itf),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hash_itf>())).digest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hash_itf),
            "::",
            stringify!(digest)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_aes_ctx {
    pub keys: [u32; 60usize],
    #[doc = " Maximum size of key schedule"]
    pub nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cry_aes_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_aes_ctx>(),
        244usize,
        concat!("Size of: ", stringify!(cry_aes_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_aes_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cry_aes_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_aes_ctx>())).keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_aes_ctx),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_aes_ctx>())).nr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_aes_ctx),
            "::",
            stringify!(nr)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx   AES context."]
    pub fn cry_aes_init(ctx: *mut cry_aes_ctx);
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx   AES context."]
    pub fn cry_aes_clear(ctx: *mut cry_aes_ctx);
}
extern "C" {
    #[doc = " Set the AES key."]
    #[doc = ""]
    #[doc = " @param ctx   AES context."]
    #[doc = " @param key   Pointer to the key."]
    #[doc = " @param size  Key size in bytes."]
    #[doc = "              Shall be 16 for AES-128, 24 for AES-192, 32 for AES-256."]
    pub fn cry_aes_key_set(
        ctx: *mut cry_aes_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Encrypt the data pointed by src into dst."]
    #[doc = " The function works in-place so dst can be equal to src."]
    #[doc = ""]
    #[doc = " @param ctx   AES context."]
    #[doc = " @param dst   Destination buffer (ciphertext)."]
    #[doc = " @param src   Source buffer (cleartext)."]
    #[doc = " @param size  Size of the data. Must be a multiple of 16."]
    pub fn cry_aes_encrypt(
        ctx: *mut cry_aes_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Decrypt the data pointed by src into dst."]
    #[doc = " The function works in-place so dst can be equal to src."]
    #[doc = ""]
    #[doc = " @param ctx   AES context."]
    #[doc = " @param dst   Destination buffer (cleartext)."]
    #[doc = " @param src   Source buffer (ciphertext)."]
    #[doc = " @param size  Size of the data. Must be a multiple of 16."]
    pub fn cry_aes_decrypt(
        ctx: *mut cry_aes_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " DES context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_des_ctx {
    pub keylen: size_t,
    pub key: [::std::os::raw::c_uchar; 24usize],
}
#[test]
fn bindgen_test_layout_cry_des_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_des_ctx>(),
        32usize,
        concat!("Size of: ", stringify!(cry_des_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_des_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_des_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_des_ctx>())).keylen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_des_ctx),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_des_ctx>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_des_ctx),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx   DES context."]
    pub fn cry_des_init(ctx: *mut cry_des_ctx);
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx   DES context."]
    pub fn cry_des_clear(ctx: *mut cry_des_ctx);
}
extern "C" {
    #[doc = " Set the DES key."]
    #[doc = ""]
    #[doc = " @param ctx   DES context."]
    #[doc = " @param key   Pointer to the key."]
    #[doc = " @param size  Key size in bytes."]
    #[doc = "              Shall be 8 for DES or 24 for TDES (EDE)."]
    pub fn cry_des_key_set(
        ctx: *mut cry_des_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Encrypt the data pointed by src into dst."]
    #[doc = " The function works in-place so dst can be equal to src."]
    #[doc = ""]
    #[doc = " @param ctx   DES context."]
    #[doc = " @param dst   Destination buffer (ciphertext)."]
    #[doc = " @param src   Source buffer (cleartext)."]
    #[doc = " @param size  Size of the data. Must be a multiple of 8."]
    pub fn cry_des_encrypt(
        ctx: *mut cry_des_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Decrypt the data pointed by src into dst."]
    #[doc = " The function works in-place so dst can be equal to src."]
    #[doc = ""]
    #[doc = " @param ctx   DES context."]
    #[doc = " @param dst   Destination buffer (cleartext)."]
    #[doc = " @param src   Source buffer (ciphertext)."]
    #[doc = " @param size  Size of the data. Must be a multiple of 16."]
    pub fn cry_des_decrypt(
        ctx: *mut cry_des_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
#[doc = " ARC4 cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_arc4_ctx {
    pub x: ::std::os::raw::c_uchar,
    #[doc = " Permutation index"]
    pub y: ::std::os::raw::c_uchar,
    #[doc = " Permutation index"]
    pub s: [::std::os::raw::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_cry_arc4_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_arc4_ctx>(),
        258usize,
        concat!("Size of: ", stringify!(cry_arc4_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_arc4_ctx>(),
        1usize,
        concat!("Alignment of ", stringify!(cry_arc4_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_arc4_ctx>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_arc4_ctx),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_arc4_ctx>())).y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_arc4_ctx),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_arc4_ctx>())).s as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_arc4_ctx),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx       ARC4 context."]
    pub fn cry_arc4_init(ctx: *mut cry_arc4_ctx);
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx       ARC4 context."]
    pub fn cry_arc4_clear(ctx: *mut cry_arc4_ctx);
}
extern "C" {
    #[doc = " Set the cipher key."]
    #[doc = ""]
    #[doc = " @param ctx   ARC4 context."]
    #[doc = " @param key   Cipher key."]
    #[doc = " @param size  Cipher key size."]
    pub fn cry_arc4_key_set(
        ctx: *mut cry_arc4_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Encryption/Decryption function."]
    #[doc = ""]
    #[doc = " @param ctx   ARC4 context."]
    #[doc = " @param dst   Destination buffer."]
    #[doc = " @param src   Source buffer."]
    #[doc = " @param size  Number of bytes."]
    pub fn cry_arc4_crypt(
        ctx: *mut cry_arc4_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
#[doc = " Trivium cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_trivium_ctx {
    pub key: [::std::os::raw::c_uchar; 10usize],
    #[doc = " Key"]
    pub s: [::std::os::raw::c_uchar; 40usize],
}
#[test]
fn bindgen_test_layout_cry_trivium_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_trivium_ctx>(),
        50usize,
        concat!("Size of: ", stringify!(cry_trivium_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_trivium_ctx>(),
        1usize,
        concat!("Alignment of ", stringify!(cry_trivium_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_trivium_ctx>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_trivium_ctx),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_trivium_ctx>())).s as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_trivium_ctx),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx   Trivium context."]
    pub fn cry_trivium_init(ctx: *mut cry_trivium_ctx);
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx   Trivium context."]
    pub fn cry_trivium_clear(ctx: *mut cry_trivium_ctx);
}
extern "C" {
    #[doc = " Set the cipher key."]
    #[doc = ""]
    #[doc = " @param ctx   Trivium context."]
    #[doc = " @param key   Cipher key."]
    #[doc = " @param size  Cipher key size."]
    pub fn cry_trivium_key_set(
        ctx: *mut cry_trivium_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Set the initialization vector."]
    #[doc = ""]
    #[doc = " Setting a new IV resets the cipher state, the key is maintained between"]
    #[doc = " resets."]
    #[doc = ""]
    #[doc = " @param ctx   Trivium context."]
    #[doc = " @param iv    Initialization vector."]
    #[doc = " @param size  Initialization vector size."]
    pub fn cry_trivium_iv_set(
        ctx: *mut cry_trivium_ctx,
        iv: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Encryption/Decryption function."]
    #[doc = ""]
    #[doc = " @param ctx   Trivium context."]
    #[doc = " @param dst   Destination buffer."]
    #[doc = " @param src   Source buffer."]
    #[doc = " @param size  Number of bytes."]
    pub fn cry_trivium_crypt(
        ctx: *mut cry_trivium_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
#[doc = " Structure used for both private and public key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_rsa_ctx {
    #[doc = "< Modulus"]
    pub n: cry_mpi,
    #[doc = "< Public exponent"]
    pub e: cry_mpi,
    #[doc = "< Private exponent"]
    pub d: cry_mpi,
    #[doc = "< First secret prime factor"]
    pub p: cry_mpi,
    #[doc = "< Second secret prime factor"]
    pub q: cry_mpi,
    #[doc = "< Padding mode"]
    pub padding: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cry_rsa_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_rsa_ctx>(),
        168usize,
        concat!("Size of: ", stringify!(cry_rsa_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_rsa_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_rsa_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).e as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).d as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).p as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).q as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_rsa_ctx>())).padding as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_rsa_ctx),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn cry_rsa_init(
        ctc: *mut cry_rsa_ctx,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_rsa_clear(ctx: *mut cry_rsa_ctx);
}
extern "C" {
    pub fn cry_rsa_encrypt(
        ctx: *mut cry_rsa_ctx,
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_rsa_decrypt(
        ctx: *mut cry_rsa_ctx,
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_rsa_sign(
        ctx: *mut cry_rsa_ctx,
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RSA signature verification."]
    #[doc = ""]
    #[doc = " Returns 1 on signature verification success, 0 on verification failure, <0 on error."]
    pub fn cry_rsa_verify(
        ctx: *mut cry_rsa_ctx,
        sig: *const ::std::os::raw::c_uchar,
        siglen: size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate RSA key pair."]
    #[doc = ""]
    #[doc = " If pubblic key exponent parameter is set to 0 then the exponent will be"]
    #[doc = " randomly generated."]
    #[doc = ""]
    #[doc = " @param ctx   RSA context that will hold the key."]
    #[doc = " @param bits  Size of public key in bits."]
    #[doc = " @param e     public exponent (e.g. 65537)."]
    pub fn cry_rsa_keygen(
        ctx: *mut cry_rsa_ctx,
        bits: size_t,
        e: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
#[doc = " CBC context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_cbc_ctx {
    #[doc = " Cipher context."]
    pub ciph_ctx: *mut ::core::ffi::c_void,
    #[doc = " Cipher interface."]
    pub ciph_itf: *const cry_ciph_itf,
    #[doc = " Counter"]
    pub ctr: [::std::os::raw::c_uchar; 16usize],
    #[doc = " Counter length"]
    pub ctrlen: size_t,
}
#[test]
fn bindgen_test_layout_cry_cbc_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_cbc_ctx>(),
        40usize,
        concat!("Size of: ", stringify!(cry_cbc_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_cbc_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_cbc_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cbc_ctx>())).ciph_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cbc_ctx),
            "::",
            stringify!(ciph_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cbc_ctx>())).ciph_itf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cbc_ctx),
            "::",
            stringify!(ciph_itf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cbc_ctx>())).ctr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cbc_ctx),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cbc_ctx>())).ctrlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cbc_ctx),
            "::",
            stringify!(ctrlen)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx       CBC context."]
    #[doc = " @param ciph_ctx  Cipher context."]
    #[doc = " @param ciph_itf  Cipher interface."]
    pub fn cry_cbc_init(
        ctx: *mut cry_cbc_ctx,
        ciph_ctx: *mut ::core::ffi::c_void,
        ciph_itf: *const cry_ciph_itf,
    );
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx       CBC context."]
    pub fn cry_cbc_clear(ctx: *mut cry_cbc_ctx);
}
extern "C" {
    #[doc = " Set the cipher key."]
    #[doc = ""]
    #[doc = " @param ctx   CBC context."]
    #[doc = " @param key   Cipher key."]
    #[doc = " @param size  Cipher key size."]
    pub fn cry_cbc_key_set(
        ctx: *mut cry_cbc_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Set the initialization vector."]
    #[doc = ""]
    #[doc = " @param ctx   CBC context."]
    #[doc = " @param iv    Initialization vector."]
    #[doc = " @param size  Initialization vector size."]
    pub fn cry_cbc_iv_set(ctx: *mut cry_cbc_ctx, iv: *const ::std::os::raw::c_uchar, size: size_t);
}
extern "C" {
    #[doc = " Encryption function."]
    #[doc = ""]
    #[doc = " @param ctx   CBC context."]
    #[doc = " @param dst   Destination buffer (ciphertext)."]
    #[doc = " @param src   Source buffer (cleartext)."]
    #[doc = " @param size  Size should be a multiple of CBC_BLOCK_SIZE"]
    pub fn cry_cbc_encrypt(
        ctx: *mut cry_cbc_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Decryption function."]
    #[doc = ""]
    #[doc = " @param ctx   CBC context."]
    #[doc = " @param dst   Destination buffer (cleartext)."]
    #[doc = " @param src   Source buffer (ciphertext)."]
    #[doc = " @param size  Size should be a multiple of CBC_BLOCK_SIZE."]
    pub fn cry_cbc_decrypt(
        ctx: *mut cry_cbc_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
#[doc = " CFB context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_cfb_ctx {
    #[doc = " Cipher context."]
    pub ciph_ctx: *mut ::core::ffi::c_void,
    #[doc = " Cipher interface."]
    pub ciph_itf: *const cry_ciph_itf,
    #[doc = " Initialization vector length"]
    pub vlen: size_t,
    #[doc = " Initialization vector data."]
    pub v: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_cry_cfb_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_cfb_ctx>(),
        40usize,
        concat!("Size of: ", stringify!(cry_cfb_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_cfb_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_cfb_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cfb_ctx>())).ciph_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cfb_ctx),
            "::",
            stringify!(ciph_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cfb_ctx>())).ciph_itf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cfb_ctx),
            "::",
            stringify!(ciph_itf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cfb_ctx>())).vlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cfb_ctx),
            "::",
            stringify!(vlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cfb_ctx>())).v as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cfb_ctx),
            "::",
            stringify!(v)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx       CFB context."]
    #[doc = " @param ciph_ctx  Cipher context."]
    #[doc = " @param ciph_itf  Cipher interface."]
    pub fn cry_cfb_init(
        ctx: *mut cry_cfb_ctx,
        ciph_ctx: *mut ::core::ffi::c_void,
        ciph_itf: *const cry_ciph_itf,
    );
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx       CFB context."]
    pub fn cry_cfb_clear(ctx: *mut cry_cfb_ctx);
}
extern "C" {
    #[doc = " Set the cipher key in the cipher context."]
    #[doc = ""]
    #[doc = " @param ctx   CFB context."]
    #[doc = " @param key   Cipher key."]
    #[doc = " @param size  Size of cipher key."]
    pub fn cry_cfb_key_set(
        ctx: *mut cry_cfb_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Set the initialization vector in the CFB context."]
    #[doc = ""]
    #[doc = " @param ctx   CFB context."]
    #[doc = " @param iv    Initialization vector."]
    #[doc = " @param size  Size of initialization vector (<= CRY_CFB_BLOCK_SIZE)."]
    pub fn cry_cfb_iv_set(ctx: *mut cry_cfb_ctx, iv: *const ::std::os::raw::c_uchar, size: size_t);
}
extern "C" {
    #[doc = " Encrypt/Decrypt function."]
    #[doc = ""]
    #[doc = " @param ctx   CFB context."]
    #[doc = " @param dst   Destination pointer."]
    #[doc = " @param src   Source pointer."]
    #[doc = " @param size  Size of source/destination."]
    pub fn cry_cfb_crypt(
        ctx: *mut cry_cfb_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Encryption function."]
    #[doc = ""]
    #[doc = " @param ctx   CFB context."]
    #[doc = " @param dst   Destination pointer (ciphertext)."]
    #[doc = " @param src   Source pointer (cleartext)."]
    #[doc = " @param size  Size of source/destination."]
    pub fn cry_cfb8_encrypt(
        ctx: *mut cry_cfb_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Decryption function."]
    #[doc = ""]
    #[doc = " @param ctx   CFB context."]
    #[doc = " @param dst   Destination pointer (cleartext)."]
    #[doc = " @param src   Source pointer (ciphertext)."]
    #[doc = " @param size  Size of ciphertext."]
    pub fn cry_cfb8_decrypt(
        ctx: *mut cry_cfb_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
#[doc = " GCM context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_gcm_ctx {
    #[doc = " Block cipher context."]
    pub ciph_ctx: *mut ::core::ffi::c_void,
    #[doc = " Block cipher interface."]
    pub ciph_itf: *const cry_ciph_itf,
    #[doc = " Initialization vector"]
    pub iv: [::std::os::raw::c_uchar; 16usize],
    #[doc = " Counter."]
    pub ctr: [::std::os::raw::c_uchar; 16usize],
    #[doc = " Hashing state"]
    pub hs: [::std::os::raw::c_uchar; 16usize],
    #[doc = " Hashing subkey."]
    pub key: [::std::os::raw::c_uchar; 16usize],
    #[doc = " Authenticated data length."]
    pub auth_len: size_t,
    #[doc = " Cipher data length."]
    pub ciph_len: size_t,
}
#[test]
fn bindgen_test_layout_cry_gcm_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_gcm_ctx>(),
        96usize,
        concat!("Size of: ", stringify!(cry_gcm_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_gcm_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_gcm_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).ciph_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(ciph_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).ciph_itf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(ciph_itf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).iv as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).ctr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).hs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(hs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).key as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).auth_len as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(auth_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_gcm_ctx>())).ciph_len as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_gcm_ctx),
            "::",
            stringify!(ciph_len)
        )
    );
}
extern "C" {
    #[doc = " Context initialization."]
    #[doc = ""]
    #[doc = " @param ctx       GCM context."]
    #[doc = " @param ciph_ctx  Cipher context."]
    #[doc = " @param ciph_itf  Cipher interface."]
    pub fn cry_gcm_init(
        ctx: *mut cry_gcm_ctx,
        ciph_ctx: *mut ::core::ffi::c_void,
        ciph_itf: *const cry_ciph_itf,
    );
}
extern "C" {
    #[doc = " Context cleanup."]
    #[doc = ""]
    #[doc = " @param ctx       GCM context."]
    pub fn cry_gcm_clear(ctx: *mut cry_gcm_ctx);
}
extern "C" {
    #[doc = " Set the key in the gcm and in the cipher context."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param key   Cipher key."]
    #[doc = " @param size  Size of cipher key."]
    pub fn cry_gcm_key_set(
        ctx: *mut cry_gcm_ctx,
        key: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Set of the initialization vector."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param iv    Initialization vector buffer."]
    #[doc = " @param size  Size of the initialization vector."]
    pub fn cry_gcm_iv_set(ctx: *mut cry_gcm_ctx, iv: *const ::std::os::raw::c_uchar, size: size_t);
}
extern "C" {
    #[doc = " Encryption function."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param dst   Destination buffer."]
    #[doc = " @param src   Source buffer."]
    #[doc = " @param size  Size of source/destination buffers."]
    pub fn cry_gcm_encrypt(
        ctx: *mut cry_gcm_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Decryption function."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param dst   Destination buffer."]
    #[doc = " @param src   Source buffer."]
    #[doc = " @param size  Size of source/destination buffers."]
    pub fn cry_gcm_decrypt(
        ctx: *mut cry_gcm_ctx,
        dst: *mut ::std::os::raw::c_uchar,
        src: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Set the additional authentication data."]
    #[doc = ""]
    #[doc = " This must me called before the encrypt (decrypt) function (data_size == 0)."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param aad   Additional authentication data buffer."]
    #[doc = " @param size  Size of the additional auth data."]
    #[doc = "              Constraint: auth_size % GCM_BLOCK_SIZE == 0."]
    pub fn cry_gcm_update(ctx: *mut cry_gcm_ctx, aad: *const ::std::os::raw::c_uchar, size: size_t);
}
extern "C" {
    #[doc = " Generate the GCM MAC (GMAC)."]
    #[doc = ""]
    #[doc = " @param ctx   GCM context."]
    #[doc = " @param mac   Message authentication code output buffer."]
    #[doc = " @param size  Should be <= GCM_BLOCK_SIZE (16)."]
    pub fn cry_gcm_digest(ctx: *mut cry_gcm_ctx, mac: *mut ::std::os::raw::c_uchar, size: size_t);
}
#[doc = " Data structure for MD5 (Message Digest) computation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_md5_ctx {
    #[doc = "< Partial input buffer"]
    pub data: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< Data length in bits"]
    pub len: [u32; 2usize],
    #[doc = "< Hash state buffer"]
    pub state: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cry_md5_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_md5_ctx>(),
        88usize,
        concat!("Size of: ", stringify!(cry_md5_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_md5_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cry_md5_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_md5_ctx>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_md5_ctx),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_md5_ctx>())).len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_md5_ctx),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_md5_ctx>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_md5_ctx),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = " Initialize the MD5 context."]
    #[doc = ""]
    #[doc = " @param ctx       MD5 context."]
    pub fn cry_md5_init(ctx: *mut cry_md5_ctx);
}
extern "C" {
    #[doc = " Clear MD5 context."]
    #[doc = ""]
    #[doc = " @param ctx   MD5 context to be cleared"]
    pub fn cry_md5_clear(ctx: *mut cry_md5_ctx);
}
extern "C" {
    #[doc = " Add data to the MD5 hash."]
    #[doc = ""]
    #[doc = " @param ctx   MD5 context."]
    #[doc = " @param data  Data array."]
    #[doc = " @param size  Data array size in octets."]
    pub fn cry_md5_update(
        ctx: *mut cry_md5_ctx,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    );
}
extern "C" {
    #[doc = " Finalize the MD5 hash."]
    #[doc = ""]
    #[doc = " @param ctx   MD5 context."]
    #[doc = " @param out   Destination buffer where the 16 octets hash will be stored."]
    pub fn cry_md5_digest(ctx: *mut cry_md5_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " MD5 computation of a given input."]
    #[doc = ""]
    #[doc = " @param out   MD5 result buffer (shall be at least 16 bytes)."]
    #[doc = " @param data  Input data buffer."]
    #[doc = " @param len   Input data length."]
    pub fn cry_md5(
        out: *mut ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_sha1_ctx {
    #[doc = "< Data block being processed"]
    pub data: [::std::os::raw::c_uchar; 64usize],
    #[doc = "< Number of data bytes processed"]
    pub len: [u32; 2usize],
    #[doc = "< Intermediate digest state"]
    pub state: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_cry_sha1_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_sha1_ctx>(),
        92usize,
        concat!("Size of: ", stringify!(cry_sha1_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_sha1_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cry_sha1_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha1_ctx>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha1_ctx),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha1_ctx>())).len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha1_ctx),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha1_ctx>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha1_ctx),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = " Initialize SHA-1 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-1 context to be initialized"]
    pub fn cry_sha1_init(ctx: *mut cry_sha1_ctx);
}
extern "C" {
    #[doc = " Clear SHA-1 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-1 context to be cleared"]
    pub fn cry_sha1_clear(ctx: *mut cry_sha1_ctx);
}
extern "C" {
    #[doc = " SHA-1 process buffer."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-1 context."]
    #[doc = " @param data  Buffer holding the data."]
    #[doc = " @param len   Length of the input data."]
    pub fn cry_sha1_update(
        ctx: *mut cry_sha1_ctx,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    #[doc = " Final digest."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-1 context"]
    #[doc = " @param out   SHA-1 result"]
    pub fn cry_sha1_digest(ctx: *mut cry_sha1_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " SHA-1 computation of a given input."]
    #[doc = ""]
    #[doc = " @param out   SHA-1 result buffer (shall be at least 20 bytes)."]
    #[doc = " @param data  Input data buffer."]
    #[doc = " @param len   Input data length."]
    pub fn cry_sha1(
        out: *mut ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_sha256_ctx {
    pub data: [::std::os::raw::c_uchar; 64usize],
    pub datalen: u32,
    pub bitlen: u64,
    pub state: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_cry_sha256_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_sha256_ctx>(),
        112usize,
        concat!("Size of: ", stringify!(cry_sha256_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_sha256_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_sha256_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha256_ctx>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha256_ctx),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha256_ctx>())).datalen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha256_ctx),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha256_ctx>())).bitlen as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha256_ctx),
            "::",
            stringify!(bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha256_ctx>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha256_ctx),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = " Initialize SHA-256 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-256 context to be initialized"]
    pub fn cry_sha256_init(ctx: *mut cry_sha256_ctx);
}
extern "C" {
    #[doc = " Clear SHA-256 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-256 context to be cleared"]
    pub fn cry_sha256_clear(ctx: *mut cry_sha256_ctx);
}
extern "C" {
    #[doc = " SHA-256 process buffer."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-256 context."]
    #[doc = " @param data  Buffer holding the data."]
    #[doc = " @param len   Length of the input data."]
    pub fn cry_sha256_update(
        ctx: *mut cry_sha256_ctx,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    #[doc = " Final digest."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-256 context"]
    #[doc = " @param out   SHA-256 result"]
    pub fn cry_sha256_digest(ctx: *mut cry_sha256_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " SHA-256 computation of a given input."]
    #[doc = ""]
    #[doc = " @param out   SHA-256 result buffer (shall be at least 32 bytes)."]
    #[doc = " @param data  Input data buffer."]
    #[doc = " @param len   Input data length."]
    pub fn cry_sha256(
        out: *mut ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_sha512_ctx {
    #[doc = "< Data block being processed"]
    pub data: [::std::os::raw::c_uchar; 128usize],
    #[doc = "< Number of data bytes processed"]
    pub len: [u64; 2usize],
    #[doc = "< Intermediate digest state"]
    pub state: [u64; 8usize],
    #[doc = "< SHA-384"]
    pub is384: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cry_sha512_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_sha512_ctx>(),
        216usize,
        concat!("Size of: ", stringify!(cry_sha512_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_sha512_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_sha512_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha512_ctx>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha512_ctx),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha512_ctx>())).len as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha512_ctx),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha512_ctx>())).state as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha512_ctx),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_sha512_ctx>())).is384 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_sha512_ctx),
            "::",
            stringify!(is384)
        )
    );
}
extern "C" {
    #[doc = " Initialize SHA-512 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-512 context to be initialized."]
    #[doc = " @param is384 Produce a SHA-384 output."]
    pub fn cry_sha512_init(ctx: *mut cry_sha512_ctx, is384: ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Clear SHA-512 context."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-512 context to be cleared"]
    pub fn cry_sha512_clear(ctx: *mut cry_sha512_ctx);
}
extern "C" {
    #[doc = " SHA-512 process buffer."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-512 context."]
    #[doc = " @param data  Buffer holding the data."]
    #[doc = " @param len   Length of the input data."]
    pub fn cry_sha512_update(
        ctx: *mut cry_sha512_ctx,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    #[doc = " Final digest."]
    #[doc = ""]
    #[doc = " @param ctx   SHA-512 context"]
    #[doc = " @param out   SHA-512 result"]
    pub fn cry_sha512_digest(ctx: *mut cry_sha512_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " SHA-512 computation of a given input."]
    #[doc = ""]
    #[doc = " @param out   SHA-512 result buffer (shall be at least 64 bytes)."]
    #[doc = " @param data  Input data buffer."]
    #[doc = " @param len   Input data length."]
    pub fn cry_sha512(
        out: *mut ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    #[doc = " SHA-384 computation of a given input."]
    #[doc = ""]
    #[doc = " @param out   SHA-384 result buffer (shall be at least 48 bytes)."]
    #[doc = " @param data  Input data buffer."]
    #[doc = " @param len   Input data length."]
    pub fn cry_sha384(
        out: *mut ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_cmac_ctx {
    #[doc = "< Block cipher context"]
    pub ciph_ctx: *mut ::core::ffi::c_void,
    #[doc = "< Block cipher interface"]
    pub ciph_itf: *const cry_ciph_itf,
    #[doc = "< Pending block size"]
    pub blklen: size_t,
    #[doc = "< Pending block"]
    pub blk: [::std::os::raw::c_uchar; 16usize],
    #[doc = "< Current MAC"]
    pub mac: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_cry_cmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_cmac_ctx>(),
        56usize,
        concat!("Size of: ", stringify!(cry_cmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_cmac_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_cmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cmac_ctx>())).ciph_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cmac_ctx),
            "::",
            stringify!(ciph_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cmac_ctx>())).ciph_itf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cmac_ctx),
            "::",
            stringify!(ciph_itf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cmac_ctx>())).blklen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cmac_ctx),
            "::",
            stringify!(blklen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cmac_ctx>())).blk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cmac_ctx),
            "::",
            stringify!(blk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_cmac_ctx>())).mac as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_cmac_ctx),
            "::",
            stringify!(mac)
        )
    );
}
extern "C" {
    pub fn cry_cmac_init(
        ctx: *mut cry_cmac_ctx,
        ciph_ctx: *mut ::core::ffi::c_void,
        ciph_itf: *const cry_ciph_itf,
        key: *const ::std::os::raw::c_uchar,
        keylen: size_t,
    );
}
extern "C" {
    pub fn cry_cmac_update(
        ctx: *mut cry_cmac_ctx,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    pub fn cry_cmac_digest(ctx: *mut cry_cmac_ctx, mac: *mut ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_hmac_ctx {
    pub hash_ctx: *mut ::core::ffi::c_void,
    pub hash_itf: *const cry_hash_itf,
    pub hash_len: size_t,
    pub key: [::std::os::raw::c_uchar; 64usize],
    pub key_len: size_t,
}
#[test]
fn bindgen_test_layout_cry_hmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_hmac_ctx>(),
        96usize,
        concat!("Size of: ", stringify!(cry_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_hmac_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_hmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hmac_ctx>())).hash_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hmac_ctx),
            "::",
            stringify!(hash_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hmac_ctx>())).hash_itf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hmac_ctx),
            "::",
            stringify!(hash_itf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hmac_ctx>())).hash_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hmac_ctx),
            "::",
            stringify!(hash_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hmac_ctx>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hmac_ctx),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hmac_ctx>())).key_len as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hmac_ctx),
            "::",
            stringify!(key_len)
        )
    );
}
extern "C" {
    pub fn cry_hmac_init(
        ctx: *mut cry_hmac_ctx,
        hash_ctx: *mut ::core::ffi::c_void,
        hash_itf: *const cry_hash_itf,
        hash_len: size_t,
        key: *const ::std::os::raw::c_uchar,
        key_len: size_t,
    );
}
extern "C" {
    pub fn cry_hmac_update(
        ctx: *mut cry_hmac_ctx,
        in_: *const ::std::os::raw::c_uchar,
        in_len: size_t,
    );
}
extern "C" {
    pub fn cry_hmac_digest(ctx: *mut cry_hmac_ctx, mac: *mut ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_dsa_ctx {
    #[doc = "< Prime modulus"]
    pub p: cry_mpi,
    #[doc = "< Prime modulus subgroup (prime divisor of p-1)"]
    pub q: cry_mpi,
    #[doc = "< Subgroup generator"]
    pub g: cry_mpi,
    #[doc = "< Private signing key"]
    pub pvt: cry_mpi,
    #[doc = "< Public verification key"]
    pub pub_: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_dsa_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_dsa_ctx>(),
        160usize,
        concat!("Size of: ", stringify!(cry_dsa_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_dsa_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_dsa_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_ctx>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_ctx),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_ctx>())).q as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_ctx),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_ctx>())).g as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_ctx),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_ctx>())).pvt as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_ctx),
            "::",
            stringify!(pvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_ctx>())).pub_ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_ctx),
            "::",
            stringify!(pub_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_dsa_sig {
    #[doc = "< Signature first component"]
    pub r: cry_mpi,
    #[doc = "< Signature second component"]
    pub s: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_dsa_sig() {
    assert_eq!(
        ::core::mem::size_of::<cry_dsa_sig>(),
        64usize,
        concat!("Size of: ", stringify!(cry_dsa_sig))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_dsa_sig>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_dsa_sig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_sig>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_sig),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dsa_sig>())).s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dsa_sig),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn cry_dsa_init(ctx: *mut cry_dsa_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dsa_clear(ctx: *mut cry_dsa_ctx);
}
extern "C" {
    pub fn cry_dsa_sign(
        ctx: *mut cry_dsa_ctx,
        sig: *mut cry_dsa_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DSA signature verification."]
    #[doc = ""]
    #[doc = " Returns 1 on signature verification success, 0 on verification failure, <0 on error."]
    pub fn cry_dsa_verify(
        ctx: *mut cry_dsa_ctx,
        sig: *const cry_dsa_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dsa_keygen(
        ctx: *mut cry_dsa_ctx,
        l: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ecdsa_ctx {
    #[doc = "< Elliptic curve group parameters"]
    pub grp: cry_ecp_grp,
    #[doc = "< Private signing key"]
    pub d: cry_mpi,
    #[doc = "< Public verification key"]
    pub q: cry_ecp,
}
#[test]
fn bindgen_test_layout_cry_ecdsa_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_ecdsa_ctx>(),
        352usize,
        concat!("Size of: ", stringify!(cry_ecdsa_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ecdsa_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ecdsa_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdsa_ctx>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdsa_ctx),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdsa_ctx>())).d as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdsa_ctx),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdsa_ctx>())).q as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdsa_ctx),
            "::",
            stringify!(q)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ecdsa_sig {
    pub r: cry_mpi,
    pub s: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_ecdsa_sig() {
    assert_eq!(
        ::core::mem::size_of::<cry_ecdsa_sig>(),
        64usize,
        concat!("Size of: ", stringify!(cry_ecdsa_sig))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ecdsa_sig>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ecdsa_sig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdsa_sig>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdsa_sig),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdsa_sig>())).s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdsa_sig),
            "::",
            stringify!(s)
        )
    );
}
pub type cry_ecdsa_rand_gen =
    ::core::option::Option<unsafe extern "C" fn(buf: *mut ::std::os::raw::c_uchar, len: size_t)>;
extern "C" {
    pub fn cry_ecdsa_sign(
        ctx: *mut cry_ecdsa_ctx,
        sig: *mut cry_ecdsa_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
        rand_gen: cry_ecdsa_rand_gen,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ECDSA signature verification."]
    #[doc = ""]
    #[doc = " Returns 1 on signature verification success, 0 on verification failure, <0 on error."]
    pub fn cry_ecdsa_verify(
        ctx: *mut cry_ecdsa_ctx,
        sig: *const cry_ecdsa_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecdsa_init(
        ctx: *mut cry_ecdsa_ctx,
        grp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecdsa_clear(ctx: *mut cry_ecdsa_ctx);
}
extern "C" {
    pub fn cry_ecdsa_keygen(ctx: *mut cry_ecdsa_ctx) -> ::std::os::raw::c_int;
}
#[doc = " Elgamal context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_elgamal_ctx {
    #[doc = "< Prime"]
    pub p: cry_mpi,
    #[doc = "< Group generator"]
    pub g: cry_mpi,
    #[doc = "< g^x mod p"]
    pub y: cry_mpi,
    #[doc = "< Secret exponent"]
    pub d: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_elgamal_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_elgamal_ctx>(),
        128usize,
        concat!("Size of: ", stringify!(cry_elgamal_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_elgamal_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_elgamal_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_ctx>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_ctx),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_ctx>())).g as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_ctx),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_ctx>())).y as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_ctx),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_ctx>())).d as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_ctx),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_elgamal_sig {
    pub r: cry_mpi,
    pub s: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_elgamal_sig() {
    assert_eq!(
        ::core::mem::size_of::<cry_elgamal_sig>(),
        64usize,
        concat!("Size of: ", stringify!(cry_elgamal_sig))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_elgamal_sig>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_elgamal_sig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_sig>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_sig),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_elgamal_sig>())).s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_elgamal_sig),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn cry_elgamal_init(ctx: *mut cry_elgamal_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_elgamal_clear(ctx: *mut cry_elgamal_ctx);
}
extern "C" {
    pub fn cry_elgamal_sign(
        ctx: *mut cry_elgamal_ctx,
        sign: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Elgamal signature verification."]
    #[doc = ""]
    #[doc = " Returns 1 on signature verification success, 0 on verification failure, <0 on error."]
    pub fn cry_elgamal_verify(
        ctx: *mut cry_elgamal_ctx,
        sign: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_elgamal_sign2(
        ctx: *mut cry_elgamal_ctx,
        sign: *mut cry_elgamal_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Elgamal signature verification."]
    #[doc = ""]
    #[doc = " Returns 1 on verification success, 0 on verification failure, <0 on error."]
    pub fn cry_elgamal_verify2(
        ctx: *mut cry_elgamal_ctx,
        sign: *const cry_elgamal_sig,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Diffie-Hellman algorithm context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_dh_ctx {
    #[doc = "< Shared modulus"]
    pub p: cry_mpi,
    #[doc = "< Shared base"]
    pub g: cry_mpi,
    #[doc = "< Secret exponent"]
    pub e: cry_mpi,
    #[doc = "< First step token"]
    pub Y: cry_mpi,
    #[doc = "< Shared secret"]
    pub Z: cry_mpi,
}
#[test]
fn bindgen_test_layout_cry_dh_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_dh_ctx>(),
        160usize,
        concat!("Size of: ", stringify!(cry_dh_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_dh_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_dh_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dh_ctx>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dh_ctx),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dh_ctx>())).g as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dh_ctx),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dh_ctx>())).e as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dh_ctx),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dh_ctx>())).Y as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dh_ctx),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_dh_ctx>())).Z as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_dh_ctx),
            "::",
            stringify!(Z)
        )
    );
}
extern "C" {
    pub fn cry_dh_init(ctx: *mut cry_dh_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dh_clear(ctx: *mut cry_dh_ctx);
}
extern "C" {
    pub fn cry_dh_agree(ctx: *mut cry_dh_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dh_finalize(ctx: *mut cry_dh_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dh_get_tok(
        ctx: *mut cry_dh_ctx,
        out: *mut ::std::os::raw::c_uchar,
        out_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dh_set_tok(
        ctx: *mut cry_dh_ctx,
        in_: *mut ::std::os::raw::c_uchar,
        in_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_dh_get_sec(
        ctx: *mut cry_dh_ctx,
        out: *mut ::std::os::raw::c_uchar,
        out_len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_ecdh_ctx {
    #[doc = "< Elliptic curve group"]
    pub grp: cry_ecp_grp,
    #[doc = "< Private key"]
    pub d: cry_mpi,
    #[doc = "< Public key"]
    pub q: cry_ecp,
    #[doc = "< Shared secret"]
    pub z: cry_ecp,
}
#[test]
fn bindgen_test_layout_cry_ecdh_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_ecdh_ctx>(),
        448usize,
        concat!("Size of: ", stringify!(cry_ecdh_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_ecdh_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_ecdh_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdh_ctx>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdh_ctx),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdh_ctx>())).d as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdh_ctx),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdh_ctx>())).q as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdh_ctx),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_ecdh_ctx>())).z as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_ecdh_ctx),
            "::",
            stringify!(z)
        )
    );
}
extern "C" {
    pub fn cry_ecdh_init(
        ctx: *mut cry_ecdh_ctx,
        grp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecdh_clear(ctx: *mut cry_ecdh_ctx);
}
extern "C" {
    pub fn cry_ecdh_agree(ctx: *mut cry_ecdh_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_ecdh_final(ctx: *mut cry_ecdh_ctx) -> ::std::os::raw::c_int;
}
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_crc16_ctx {
    pub tab: *const u16,
    pub crc: u16,
    pub flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_cry_crc16_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_crc16_ctx>(),
        16usize,
        concat!("Size of: ", stringify!(cry_crc16_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_crc16_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_crc16_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc16_ctx>())).tab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc16_ctx),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc16_ctx>())).crc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc16_ctx),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc16_ctx>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc16_ctx),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_crc32_ctx {
    pub tab: *const u32,
    pub crc: u32,
    pub flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_cry_crc32_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_crc32_ctx>(),
        16usize,
        concat!("Size of: ", stringify!(cry_crc32_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_crc32_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_crc32_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc32_ctx>())).tab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc32_ctx),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc32_ctx>())).crc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc32_ctx),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_crc32_ctx>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_crc32_ctx),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Initialize a generic CRC-16 algoritm context."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    #[doc = " @param start algorithm start value."]
    #[doc = " @param tab   precomputed lookup table."]
    #[doc = " @param flags algorithm behaviour flags."]
    pub fn cry_crc16_init(
        ctx: *mut cry_crc16_ctx,
        start: u16,
        tab: *const u16,
        flags: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " CRC update"]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    pub fn cry_crc16_update(
        ctx: *mut cry_crc16_ctx,
        in_: *const ::std::os::raw::c_uchar,
        n: size_t,
    );
}
extern "C" {
    #[doc = " CRC finalize"]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    #[doc = " @return      CRC result."]
    pub fn cry_crc16_final(ctx: *mut cry_crc16_ctx) -> u16;
}
extern "C" {
    #[doc = " CRC finalize with a byte array output."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    #[doc = " @param out   CRC as a BE byte array."]
    pub fn cry_crc16_digest(ctx: *mut cry_crc16_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " Initialize as a CRC-16-CCITT algorithm."]
    #[doc = ""]
    #[doc = " Used by: x.25, V.41, HDLC, XMODEM, Bluetooth, SD and many others."]
    #[doc = " Polynomial: x^16 + x^12 + x^5 + 1."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    pub fn cry_crc16_ccitt_init(ctx: *mut cry_crc16_ctx);
}
extern "C" {
    #[doc = " CRC-16-CCITT all in one function."]
    #[doc = ""]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    #[doc = " @return      CRC value."]
    pub fn cry_crc16_ccitt(in_: *const ::std::os::raw::c_uchar, n: size_t) -> u16;
}
extern "C" {
    #[doc = " Initialize as a CRC-16-IBM algorithm"]
    #[doc = ""]
    #[doc = " Also known as CRC-16-ANSI."]
    #[doc = " Used by: Bisync, Modbus, USB, ANSI X.28 and many others."]
    #[doc = " Polynomial: x^16 + x^15 + x^2 + 1."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    pub fn cry_crc16_ibm_init(ctx: *mut cry_crc16_ctx);
}
extern "C" {
    #[doc = " CRC-16-IBM all in one function."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    #[doc = " @return      CRC value."]
    pub fn cry_crc16_ibm(in_: *const ::std::os::raw::c_uchar, n: size_t) -> u16;
}
extern "C" {
    #[doc = " Initialize as a CRC-16-DNP algorithm"]
    #[doc = ""]
    #[doc = " Standardized by: CEI EN 60870-5-1"]
    #[doc = " Used by: CTR protocol."]
    #[doc = " Polynomial: x^16 + x^13 + x^12 + x^11 + x^10 + x^8 + x^6 + x^5 + x^2 + 1."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-16 context."]
    pub fn cry_crc16_dnp_init(ctx: *mut cry_crc16_ctx);
}
extern "C" {
    #[doc = " CRC-16-DNP all in one function."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    #[doc = " @return      CRC value."]
    pub fn cry_crc16_dnp(in_: *const ::std::os::raw::c_uchar, n: size_t) -> u16;
}
extern "C" {
    #[doc = " Initialize a generic CRC-32 algoritm context."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-32 context."]
    #[doc = " @param start algorithm start value."]
    #[doc = " @param tab   precomputed lookup table."]
    #[doc = " @param flags algorithm behaviour flags."]
    pub fn cry_crc32_init(
        ctx: *mut cry_crc32_ctx,
        start: u32,
        tab: *const u32,
        flags: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " CRC update"]
    #[doc = ""]
    #[doc = " @param ctx   CRC-32 context."]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    pub fn cry_crc32_update(
        ctx: *mut cry_crc32_ctx,
        in_: *const ::std::os::raw::c_uchar,
        n: size_t,
    );
}
extern "C" {
    #[doc = " CRC finalize"]
    #[doc = ""]
    #[doc = " @param ctx   CRC-32 context."]
    #[doc = " @return      CRC result."]
    pub fn cry_crc32_final(ctx: *mut cry_crc32_ctx) -> u32;
}
extern "C" {
    #[doc = " CRC finalize with a byte array output."]
    #[doc = ""]
    #[doc = " @param ctx   CRC-32 context."]
    #[doc = " @param out   CRC as a BE byte array."]
    pub fn cry_crc32_digest(ctx: *mut cry_crc32_ctx, out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " Initialize as a CRC-32-ETH algorithm."]
    #[doc = ""]
    #[doc = " Used by: Ethernet, ISO 3309, ANSI X3.66, FIPS PUB 71, ITU-T V.42, SATA,"]
    #[doc = "          MPEG-2, Gzip, PKZIP, POSIX cksum, PNG, ZMODEM."]
    #[doc = " Polynomial:"]
    #[doc = "  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0"]
    #[doc = ""]
    #[doc = " @param ctx   CRC-32 context."]
    pub fn cry_crc32_eth_init(ctx: *mut cry_crc32_ctx);
}
extern "C" {
    #[doc = " CRC-32-ETH all in one function."]
    #[doc = ""]
    #[doc = " @param in    Buffer pointer."]
    #[doc = " @param n     Number of octets in the buffer."]
    #[doc = " @return      CRC value."]
    pub fn cry_crc32_eth(in_: *const ::std::os::raw::c_uchar, n: size_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_affine_ctx {
    pub keya: [::std::os::raw::c_uchar; 32usize],
    pub inva: [::std::os::raw::c_uchar; 32usize],
    pub keyb: [::std::os::raw::c_uchar; 32usize],
    pub keylen: size_t,
}
#[test]
fn bindgen_test_layout_cry_affine_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_affine_ctx>(),
        104usize,
        concat!("Size of: ", stringify!(cry_affine_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_affine_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_affine_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_affine_ctx>())).keya as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_affine_ctx),
            "::",
            stringify!(keya)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_affine_ctx>())).inva as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_affine_ctx),
            "::",
            stringify!(inva)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_affine_ctx>())).keyb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_affine_ctx),
            "::",
            stringify!(keyb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_affine_ctx>())).keylen as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_affine_ctx),
            "::",
            stringify!(keylen)
        )
    );
}
extern "C" {
    pub fn cry_affine_init(
        ctx: *mut cry_affine_ctx,
        keya: *const ::std::os::raw::c_uchar,
        keyb: *const ::std::os::raw::c_uchar,
        keylen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_affine_encrypt(
        ctx: *mut cry_affine_ctx,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    pub fn cry_affine_decrypt(
        ctx: *mut cry_affine_ctx,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cry_hill_ctx {
    pub key: [::std::os::raw::c_uchar; 100usize],
    pub ikey: [::std::os::raw::c_uchar; 100usize],
    pub n: size_t,
}
#[test]
fn bindgen_test_layout_cry_hill_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cry_hill_ctx>(),
        208usize,
        concat!("Size of: ", stringify!(cry_hill_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cry_hill_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(cry_hill_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hill_ctx>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hill_ctx),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hill_ctx>())).ikey as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hill_ctx),
            "::",
            stringify!(ikey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cry_hill_ctx>())).n as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cry_hill_ctx),
            "::",
            stringify!(n)
        )
    );
}
extern "C" {
    pub fn cry_hill_init(
        ctx: *mut cry_hill_ctx,
        key: *const ::std::os::raw::c_uchar,
        ikey: *const ::std::os::raw::c_uchar,
        keylen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cry_hill_encrypt(
        ctx: *mut cry_hill_ctx,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
extern "C" {
    pub fn cry_hill_decrypt(
        ctx: *mut cry_hill_ctx,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
